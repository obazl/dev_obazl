load(
    "@obazl_rules_ocaml//ocaml:rules.bzl",
    "ocaml_archive",
    "ocaml_library",
    "ocaml_module",
    "ocaml_test",
)
load("@obazl_rules_ocaml//ocaml:macros.bzl", "ns_env")

# This demo shows how the renaming and aliasing mechanisms can be used as footguns.

# This example is the same as set010/case12, except that in this
# case there is an interdependency among submodules.
# Here green.ml refers to module 'Blue', whereas in case11 it referred
# to 'Grue__Blue'. (Ditto for test.ml). To make this work we need
# a resolver for the ns_env containing these two files, which will be
# generated from the 'aliases' attribute. In particular, the generated
# resolver will contain 'module Blue = Grue__Blue', so the reference to
# 'Blue' will resolve.

# Note that we are _not_ using an ocaml_ns_library in this case. The
# resolver generated by ns_env is used only to facilitate compilation of
# the files listed in its aliases attribute.

# To complicate things a little more: red.ml wants to refer to Blue
# too. If it refers to 'Blue', its compile will fail with 'Unbound
# module Blue', since Blue will be renamed to Grue__Blue, and red.ml
# is not listed in the aliases attribute of the ns_grue env. That means
# that the resolver for ns_grue will _not_ be used to facilitate compilation
# of red.ml.  But red.ml _can_ refer to 'Grue__Blue'.

# (We do not use an ns_env for red.ml, so it will not be renamed.)

# Same considerations apply to test.ml, which refers Grue__Green and Grue__Blue.

# The upshot is that 1) the resolver module is used solely to
# facilitate compilation of the modules in its aliases attribute, and
# 2) the same module is exposed under two different names, Blue and Grue_Blue.

# This is for purposes of illustration only. In real code you would
# probably not want to do things this way. Instead you would use an
# ocaml_ns_library, and modules would be accessible using module paths
# like A.Blue. The next two demos (set010/case14, case15) show this
# (as do most of the demos in other classes).

ns_env(
    name = "ns_grue",
    aliases = [
        "blue.ml",
        "green.ml",
    ],
    prefix = "grue",
)

ocaml_test(
    name = "test",
    deps_opam = ["ounit2"],
    main = "test.ml",
    opts = [
        "-w",
        "-27",
    ],  ## Error (warning 27): unused variable test_ctxt.
    deps = [
        ":_Blue",
        ":_Green",
        ":_Red",
    ],
)

ocaml_module(
    name = "_Red",
    struct = "red.ml",  # no ns_env => red.cmo
    # we could add 'ns_env = ":ns_grue"', in which case we would get 'Grue__Red.cmo'
    deps = [":_Blue"],
)

ocaml_module(
    name = "_Green",
    ns_env = ":ns_grue",
    struct = "green.ml",  # => Grue__Green
    deps = [":_Blue"],
)

ocaml_module(
    name = "_Blue",
    ns_env = ":ns_grue",
    struct = "blue.ml",  # => Grue__Blue
)
